---
layout: post
title: Blog Post 4
---

In this blog post, I will walk through the process of creating a spectral clustering algorithm.

2022-02-11

```python
import numpy as np
from sklearn import metrics
from sklearn import datasets
from matplotlib import pyplot as plt
```


```python
n = 200
np.random.seed(1111)
X, y = datasets.make_blobs(n_samples=n, shuffle=True, random_state=None, centers = 2, cluster_std = 2.0)
plt.scatter(X[:,0], X[:,1])
```




    <matplotlib.collections.PathCollection at 0x7fface319640>




    
![png](output_1_1.png)
    



```python
from sklearn.cluster import KMeans
km = KMeans(n_clusters = 2)
km.fit(X)

plt.scatter(X[:,0], X[:,1], c = km.predict(X))
```




    <matplotlib.collections.PathCollection at 0x7ffacb2b9730>




    
![png](output_2_1.png)
    



```python
np.random.seed(1234)
n = 200
X, y = datasets.make_moons(n_samples=n, shuffle=True, noise=0.05, random_state=None)
plt.scatter(X[:,0], X[:,1])
```




    <matplotlib.collections.PathCollection at 0x7ffaccded9a0>




    
![png](output_3_1.png)
    



```python
km = KMeans(n_clusters = 2)
km.fit(X)
plt.scatter(X[:,0], X[:,1], c = km.predict(X))
```




    <matplotlib.collections.PathCollection at 0x7ffaccdaa310>




    
![png](output_4_1.png)
    


## Part A

if point i is close = 1, otherwise 0
find distance between all pairs of points (sklearn)
check whether distances are larger than epsilon
make modification on diagonal 


```python
epsilon = 0.4
```


```python
A = metrics.pairwise_distances(X=X)
A
```




    array([[0.        , 1.27292462, 1.33315598, ..., 1.9812102 , 1.68337039,
            1.94073324],
           [1.27292462, 0.        , 1.46325112, ..., 1.93729167, 1.68543003,
            1.91287315],
           [1.33315598, 1.46325112, 0.        , ..., 0.64857172, 0.35035968,
            0.60860868],
           ...,
           [1.9812102 , 1.93729167, 0.64857172, ..., 0.        , 0.30070415,
            0.04219636],
           [1.68337039, 1.68543003, 0.35035968, ..., 0.30070415, 0.        ,
            0.26255757],
           [1.94073324, 1.91287315, 0.60860868, ..., 0.04219636, 0.26255757,
            0.        ]])




```python
A = (A <= epsilon)
A
```




    array([[ True, False, False, ..., False, False, False],
           [False,  True, False, ..., False, False, False],
           [False, False,  True, ..., False,  True, False],
           ...,
           [False, False, False, ...,  True,  True,  True],
           [False, False,  True, ...,  True,  True,  True],
           [False, False, False, ...,  True,  True,  True]])




```python
A = 1.0*A
A
```




    array([[1., 0., 0., ..., 0., 0., 0.],
           [0., 1., 0., ..., 0., 0., 0.],
           [0., 0., 1., ..., 0., 1., 0.],
           ...,
           [0., 0., 0., ..., 1., 1., 1.],
           [0., 0., 1., ..., 1., 1., 1.],
           [0., 0., 0., ..., 1., 1., 1.]])




```python
np.fill_diagonal(a=A, val=0)
A
```




    array([[0., 0., 0., ..., 0., 0., 0.],
           [0., 0., 0., ..., 0., 0., 0.],
           [0., 0., 0., ..., 0., 1., 0.],
           ...,
           [0., 0., 0., ..., 0., 1., 1.],
           [0., 0., 1., ..., 1., 0., 1.],
           [0., 0., 0., ..., 1., 1., 0.]])



## Part B

### B.1 The cut term

make up vector y, use from line 4
start with make_moons: they give you X and y
X is coord, y tells which moons
y is correct answer


```python
y
```




    array([1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
           1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0,
           0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0,
           0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0,
           0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1,
           0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0,
           0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
           1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0,
           0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0,
           0, 0])




```python
sum(sum(A))
```




    4516.0



Here `y` is the array of labels for the clusters $C_0$ and $C_1$.


```python
def cut(A,y):
    count = 0
    for i in range(y.size):
        for j in range(i, n):
            if y[i] != y[j]:
                count += A[i][j]
    return count
```


```python
cut(A,y)
```




    13.0




```python
z = np.random.randint(2, size=n)
cut(A,z)
```




    1159.0



### B.2 The volume term

We want to find that:

1. There are relatively few entries in A that indicate points in $C_0$ are close to points in $C_1$.
2. The volumes of $C_0$ and $C_1$ are not too small.


```python
def vols(A,y):
    vol_1 = sum(y@A)
    total_vol = sum(sum(A))
    vol_0 = total_vol - vol_1
    return (vol_0, vol_1)
```


```python
vols(A,y)
```




    (2299.0, 2217.0)




```python
def normcut(A,y):
    vol_0, vol_1 = vols(A,y)
    return cut(A,y)*(1/vol_0 + 1/vol_1)
```


```python
normcut(A,y)
```




    0.011518412331615225



## Part C

1. `transform(A,y)` function


```python
def transform(A,y):
    vol_0, vol_1 = vols(A,y)
    z = y*(-1/vol_1 - 1/vol_0) + (1/vol_0)
    return z
```


```python
z = transform(A,y)
z[:5]
```




    array([-0.00045106, -0.00045106,  0.00043497,  0.00043497,  0.00043497])



2. Now, we do some linear algebra to calculate the binary norm cut objective.


```python
# diagonal matrix D
D = np.ndarray(shape=(n,n))
np.fill_diagonal(a=D, val=sum(A))
D
```




    array([[15.,  0.,  0., ...,  0.,  0.,  0.],
           [ 0., 25.,  0., ...,  0.,  0.,  0.],
           [ 0.,  0., 24., ...,  0.,  0.,  0.],
           ...,
           [ 0.,  0.,  0., ..., 26.,  0.,  0.],
           [ 0.,  0.,  0., ...,  0., 28.,  0.],
           [ 0.,  0.,  0., ...,  0.,  0., 26.]])




```python
N = (np.transpose(z) @ (D-A) @ z)/(np.transpose(z) @ D @ z)
N
```




    0.011518412331615126




```python
np.isclose(normcut(A,y), N)
```




    True



We get that the linear algebra formula gives the same result as the `normcut(A,y)` function above.

3. Check the identity


```python
np.isclose(np.transpose(z) @ D @ np.ones(n), 0)
```




    True



## Part D


```python
def orth(u, v):
    return (u @ v) / (v @ v) * v

e = np.ones(n) 

d = D @ e

def orth_obj(z):
    z_o = z - orth(z, d)
    return (z_o @ (D - A) @ z_o)/(z_o @ D @ z_o)
```


```python
from scipy import optimize
min_fcn = optimize.minimize(fun=orth_obj,x0=e)
z_min = min_fcn.x
```

## Part E


```python
plt.scatter(X[z_min<0][:,0], X[z_min<0][:,1], c = 'red')
plt.scatter(X[z_min>=0][:,0], X[z_min>=0][:,1], c = 'blue')
```




    <matplotlib.collections.PathCollection at 0x7fface01e370>




    
![png](output_39_1.png)
    


## Part F


```python
L = np.linalg.inv(D)@(D-A)
```


```python
eig_values = np.linalg.eig(L)[0]
order_values = np.sort(eig_values)
sec_smallest = order_values[1]
index, = np.where(eig_values == sec_smallest)
index[0]
```




    1




```python
color = ['red' if (z_eig[i]<0) else 'blue' for i in range(z_eig.size)]
plt.scatter(X[:,0], X[:,1], c = color)
```




    <matplotlib.collections.PathCollection at 0x7ffacc55cf70>




    
![png](output_43_1.png)
    


## Part G


```python
def spectral_clustering(X, epsilon): 
    A = metrics.pairwise_distances(X=X)
    A = (A <= epsilon)*1.0
    np.fill_diagonal(a=A, val=0)
    D = np.ndarray(shape=(n,n))
    np.fill_diagonal(a=D, val=sum(A))
    L = np.linalg.inv(D)@(D-A)
    z_eig = np.linalg.eig(L)[0]
    color = ['red' if (z_eig[i]<0) else 'blue' for i in range(n)]
```

## Part H


```python
n = 1000

```

## Part I


```python
n = 1000
X, y = datasets.make_circles(n_samples=n, shuffle=True, noise=0.05, random_state=None, factor = 0.4)
plt.scatter(X[:,0], X[:,1])
```




    <matplotlib.collections.PathCollection at 0x7fface4bd4c0>




    
![png](output_49_1.png)
    



```python
km = KMeans(n_clusters = 2)
km.fit(X)
plt.scatter(X[:,0], X[:,1], c = km.predict(X))
```




    <matplotlib.collections.PathCollection at 0x7fface63f880>




    
![png](output_50_1.png)
    



```python
spectural_clustering(X, epsilon)
```
